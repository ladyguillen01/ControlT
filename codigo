######### MODELO LOGAR칈TMICO PARAMETRIZADO ###############################################

import pandas as pd
import numpy as np
from sklearn.metrics import r2_score
from scipy.optimize import curve_fit

# --- 1) Preparamos los datos ---
data2[["maduracion", "pdponderado", "provisionporcacum"]] = data2[
    ["maduracion", "pdponderado", "provisionporcacum"]
].apply(pd.to_numeric, errors="coerce")
data2 = data2.dropna(subset=["maduracion", "pdponderado", "provisionporcacum"])
data2 = data2[data2["maduracion"] >= 0]
df = data2.copy()

mad = df["maduracion"].values
pdv = df["pdponderado"].values
y = df["provisionporcacum"].values

# --- 2) Definimos el modelo ---
def modelo_log(pdv, mad, A1, A2, A3, B1, B2, B3, C1, C2, C3, D1, D2, D3):
    a = A1*pdv**2 + A2*pdv + A3
    b = B1*pdv**2 + B2*pdv + B3
    c = C1*pdv**2 + C2*pdv + C3
    d = D1*pdv**2 + D2*pdv + D3
    
    # log_base_a(x) = np.log(x) / np.log(a)
    return (np.log(mad + b) / np.log(a)) * c + d

# --- 3) Ajuste no lineal ---
p0 = np.ones(12) * 0.1  # valores iniciales
params, cov = curve_fit(lambda X1, X2, *p: modelo_log(X1, X2, *p),
                        (pdv, mad), y, p0=p0, maxfev=100000)

# --- 4) Predicciones y m칠tricas ---
y_pred = modelo_log(pdv, mad, *params)
r2 = r2_score(y, y_pred)
corr = np.corrcoef(y, y_pred)[0, 1]

# --- 5) Resultados ---
coef_names = ["A1","A2","A3","B1","B2","B3","C1","C2","C3","D1","D2","D3"]
resumen_coef = pd.DataFrame({"Par치metro": coef_names, "Valor": params.round(8)})
print("游늳 COEFICIENTES DEL MODELO:")
print(resumen_coef.to_string(index=False))

print("\n游늵 M칄TRICAS DEL AJUSTE:")
print(f"R = {r2:.6f}")
print(f"Correlaci칩n (Pearson) = {corr:.6f}")

# --- 6) F칩rmula general ---
print("\n游닂 MODELO GENERAL:")
print("y = log_a(maduracion + b) * c + d")
print("Donde:")
print("  a = (A1*pd^2 + A2*pd + A3)")
print("  b = (B1*pd^2 + B2*pd + B3)")
print("  c = (C1*pd^2 + C2*pd + C3)")
print("  d = (D1*pd^2 + D2*pd + D3)")



####2
import pandas as pd
import numpy as np
from sklearn.metrics import r2_score
from scipy.optimize import curve_fit

# --- 1) Datos ---
data2[["maduracion", "pdponderado", "provisionporcacum"]] = data2[
    ["maduracion", "pdponderado", "provisionporcacum"]
].apply(pd.to_numeric, errors="coerce")

df = data2.dropna(subset=["maduracion", "pdponderado", "provisionporcacum"])
mad = df["maduracion"].values
pdv = df["pdponderado"].values
y = df["provisionporcacum"].values

# --- 2) Selecciona la forma funcional: 'linear', 'quadratic' o 'log'
form = "linear"

def f_dep(p, pdv, form):
    """Dependencia funcional flexible."""
    if form == "linear":
        return p[0]*pdv + p[1]
    elif form == "quadratic":
        return p[0]*pdv**2 + p[1]*pdv + p[2]
    elif form == "log":
        return p[0]*np.log(pdv + 1) + p[1]
    else:
        raise ValueError("Forma no reconocida")

# --- 3) Definir el modelo general ---
def modelo(pdv, mad,
           A1, A2, B1, B2, C1, C2, D1, D2):  # lineal (2 coef por par치metro)
    
    a = f_dep([A1, A2], pdv, form)
    b = f_dep([B1, B2], pdv, form)
    c = f_dep([C1, C2], pdv, form)
    d = f_dep([D1, D2], pdv, form)
    
    return (np.log(mad + b) / np.log(a)) * c + d

# --- 4) Ajuste ---
p0 = np.ones(8) * 0.5
params, _ = curve_fit(lambda x1, x2, *p: modelo(x1, x2, *p),
                      (pdv, mad), y, p0=p0, maxfev=100000)

# --- 5) Evaluaci칩n ---
y_pred = modelo(pdv, mad, *params)
r2 = r2_score(y, y_pred)
corr = np.corrcoef(y, y_pred)[0, 1]

print(f"游늵 R = {r2:.5f} | Corr = {corr:.5f}")
print(f"Forma funcional usada: {form}")
print("Coeficientes:", np.round(params, 6))

